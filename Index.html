<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Interactive Skill Tree + 2D Game Demo</title>
<style>
  :root{
    --bg:#0f1724; --panel:#0b1220; --accent:#6ee7b7; --muted:#94a3b8; --node:#112236;
    --glow: 0 6px 20px rgba(46, 204, 113, .08);
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    color: #e6eef8;
  }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071025 0%, #071a2b 100%);}
  .wrap{display:flex;gap:18px;padding:18px;box-sizing:border-box;height:100%;}
  .panel{
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.04);
    border-radius:12px;
    box-shadow:var(--glow);
    padding:14px;
  }
  .left{width:420px;flex-shrink:0;display:flex;flex-direction:column;gap:12px;}
  .right{flex:1;display:flex;flex-direction:column;gap:12px;}
  header{display:flex;align-items:center;justify-content:space-between;}
  header h1{font-size:16px;margin:0;color:var(--accent);}
  .meta{font-size:13px;color:var(--muted);}
  .skill-area{height:calc(100% - 86px);overflow:auto;padding:12px;background:transparent;}
  .canvas-wrap{flex:1;display:flex;flex-direction:column;gap:12px;}
  #gameCanvas{background:linear-gradient(180deg,#0b213a,#062034);border-radius:8px;border:1px solid rgba(255,255,255,0.03);}
  .hud{display:flex;gap:12px;align-items:center;justify-content:space-between;}
  .controls{display:flex;gap:8px;align-items:center;}
  button{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;color:var(--accent);cursor:pointer;font-weight:600}
  button.secondary{color:var(--muted);border-style:dashed}
  .skill-tree{
    position:relative;width:100%;height:640px;background:linear-gradient(180deg, rgba(255,255,255,0.005), transparent);
    border-radius:10px;padding:18px;box-sizing:border-box;
  }
  .node{
    position:absolute;width:120px;height:56px;border-radius:8px;padding:8px;box-sizing:border-box;
    background:linear-gradient(180deg, #071a2a, #0b2a44);border:1px solid rgba(255,255,255,0.05);
    display:flex;flex-direction:column;justify-content:center;align-items:flex-start;gap:2px;cursor:pointer;
    transition:transform .12s ease, box-shadow .12s ease, border-color .12s;
  }
  .node.locked{opacity:.4;filter:grayscale(20%);}
  .node.unlocked{border-color:rgba(110,231,183,0.14);box-shadow:0 8px 30px rgba(110,231,183,0.06);}
  .node .title{font-size:14px;font-weight:700}
  .node .sub{font-size:12px;color:var(--muted)}
  .node .cost{position:absolute;right:8px;top:8px;background:rgba(0,0,0,0.25);padding:4px 6px;border-radius:6px;font-size:12px}
  .line{position:absolute;pointer-events:none;}
  .footer-actions{display:flex;gap:8px;align-items:center;justify-content:flex-end}
  .points{font-size:14px;color:#fff;font-weight:700}
  .tooltip{
    position:fixed;background:#0b1220;border:1px solid rgba(255,255,255,0.04);padding:8px 10px;border-radius:8px;font-size:13px;color:var(--muted);
    pointer-events:none;transform:translate(-50%,-120%);white-space:nowrap;z-index:999;
  }
  .legend{display:flex;gap:8px;align-items:center;font-size:13px;color:var(--muted)}
  .dot{width:10px;height:10px;border-radius:50%}
  .dot.locked{background:#2b3a4b}
  .dot.unlocked{background:var(--accent)}
  /* Responsive */
  @media (max-width:880px){
    .wrap{flex-direction:column;padding:12px;}
    .left{width:100%;}
    .skill-area{height:520px}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="left panel">
    <header>
      <div>
        <h1>Skill Tree</h1>
        <div class="meta">Points <span id="pointsRem" class="points">5</span></div>
      </div>
      <div class="legend">
        <div style="display:flex;flex-direction:column;align-items:flex-end">
          <div class="meta">Status</div>
          <div style="display:flex;gap:6px;margin-top:6px;">
            <div style="display:flex;align-items:center;gap:6px"><span class="dot unlocked"></span><span class="meta">Unlocked</span></div>
            <div style="display:flex;align-items:center;gap:6px"><span class="dot locked"></span><span class="meta">Locked</span></div>
          </div>
        </div>
      </div>
    </header>

    <div class="skill-area panel" aria-hidden="false">
      <div id="skillTree" class="skill-tree"></div>
    </div>

    <div class="footer-actions" style="margin-top:8px;">
      <button id="resetBtn" class="secondary">Reset Tree</button>
      <button id="saveBtn">Save</button>
      <button id="loadBtn" class="secondary">Load</button>
    </div>
  </div>

  <div class="right panel">
    <div class="canvas-wrap">
      <div class="hud">
        <div>
          <div class="meta">Controls: ← → (move), ↑/Space (jump), X (shoot), Shift (dash)</div>
        </div>
        <div class="controls">
          <div class="meta">HP: <span id="hpDisplay">5</span></div>
          <div class="meta">Score: <span id="score">0</span></div>
        </div>
      </div>
      <canvas id="gameCanvas" width="900" height="480"></canvas>
      <div style="display:flex;justify-content:space-between;align-items:center;">
        <div class="meta">Unlocked abilities will change gameplay instantly.</div>
        <div>
          <button id="respawnBtn" class="secondary">Respawn</button>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="tooltip" class="tooltip" style="display:none"></div>

<script>
/* ===========================
   Skill tree definition
   =========================== */
const SKILLS = {
  speed: {
    id:'speed', name:'Sprint', desc:'Increase run speed by 30%.', cost:1,
    pos:{x:40,y:40},
    applies: s => { s.playerSpeed *= 1.3; }
  },
  doubleJump: {
    id:'doubleJump', name:'Double Jump', desc:'Gain a double-jump.', cost:2,
    pos:{x:40,y:150},
    requires:['speed'],
    applies: s => { s.canDoubleJump = true; }
  },
  dash: {
    id:'dash', name:'Dash', desc:'Short horizontal dash bound to Shift.', cost:2,
    pos:{x:160,y:95},
    requires:['speed'],
    applies: s => { s.canDash = true; s.dashCooldown = 0; }
  },
  attack: {
    id:'attack', name:'Rapid Fire', desc:'Shoot bullets and reduce attack cooldown by 30%.', cost:2,
    pos:{x:280,y:40},
    requires:[],
    applies: s => { s.canShoot = true; s.attackCooldown *= 0.7; }
  },
  hp: {
    id:'hp', name:'Toughness', desc:'Increase max HP by +3.', cost:2,
    pos:{x:280,y:150},
    requires:['attack'],
    applies: s => { s.maxHp += 3; s.hp = Math.min(s.hp + 3, s.maxHp); }
  },
  crit: {
    id:'crit', name:'Critical Strike', desc:'Small chance to do double damage.', cost:1,
    pos:{x:160,y:240},
    requires:['doubleJump','dash'],
    applies: s => { s.critChance += 0.12; }
  }
};

const DEFAULT_POINTS = 5;

/* ==============
   State & Storage
   ============== */
let state = {
  points: DEFAULT_POINTS,
  unlocked: {},
  settings: {
    playerSpeed: 3.0,
    canDoubleJump: false,
    canDash: false,
    canShoot: false,
    attackCooldown: 600, // ms
    maxHp: 5,
    hp: 5,
    critChance: 0.02
  }
};

const storageKey = 'skilltree_demo_v1';

/* ==============
   Rendering Skill Tree
   ============== */
const treeRoot = document.getElementById('skillTree');
const tooltip = document.getElementById('tooltip');

function createNode(skill){
  const node = document.createElement('div');
  node.className = 'node locked';
  node.id = 'node-'+skill.id;
  node.style.left = skill.pos.x + 'px';
  node.style.top = skill.pos.y + 'px';
  node.innerHTML = `<div class="title">${skill.name}</div>
                    <div class="sub">${skill.desc}</div>
                    <div class="cost">${skill.cost}</div>`;
  node.onclick = () => { toggleSkill(skill.id); };
  node.onmousemove = ev => {
    showTooltip(skill, ev.clientX, ev.clientY);
  };
  node.onmouseleave = hideTooltip;
  return node;
}

function drawConnections(){
  // Remove old lines
  document.querySelectorAll('.line').forEach(n=>n.remove());
  Object.values(SKILLS).forEach(s=>{
    if(!s.requires) return;
    s.requires.forEach(reqId=>{
      const fromEl = document.getElementById('node-'+reqId);
      const toEl = document.getElementById('node-'+s.id);
      if(!fromEl || !toEl) return;
      const fx = fromEl.offsetLeft + fromEl.offsetWidth/2;
      const fy = fromEl.offsetTop + fromEl.offsetHeight/2;
      const tx = toEl.offsetLeft + toEl.offsetWidth/2;
      const ty = toEl.offsetTop + toEl.offsetHeight/2;
      const line = document.createElement('canvas');
      line.className = 'line';
      line.width = Math.abs(tx-fx)+40;
      line.height = Math.abs(ty-fy)+40;
      line.style.left = Math.min(fx,tx)-20 + 'px';
      line.style.top  = Math.min(fy,ty)-20 + 'px';
      const ctx = line.getContext('2d');
      ctx.clearRect(0,0,line.width,line.height);
      ctx.lineWidth = 3;
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      ctx.beginPath();
      ctx.moveTo(fx > tx ? (line.width - 20) : 20, fy > ty ? (line.height - 20) : 20);
      // curved
      ctx.bezierCurveTo(line.width/2, 20, line.width/2, line.height-20, tx > fx ? (line.width - 20) : 20, ty > fy ? (line.height - 20) : 20);
      ctx.stroke();
      treeRoot.appendChild(line);
    });
  });
}

function showTooltip(skill, x, y){
  tooltip.style.display = 'block';
  tooltip.style.left = x + 'px';
  tooltip.style.top = y + 'px';
  let reqs = '';
  if(skill.requires && skill.requires.length) reqs = '<div style="color:#9fb0c7;margin-top:4px">Requires: '+skill.requires.map(r=>SKILLS[r].name).join(', ')+'</div>';
  tooltip.innerHTML = `<strong style="color:var(--accent)">${skill.name}</strong><div style="margin-top:6px">${skill.desc}</div>
  <div style="margin-top:4px">Cost: <b>${skill.cost}</b></div>${reqs}`;
}

function hideTooltip(){ tooltip.style.display = 'none'; }

function renderTree(){
  treeRoot.innerHTML = '';
  // nodes
  Object.values(SKILLS).forEach(s => {
    const el = createNode(s);
    treeRoot.appendChild(el);
  });
  drawConnections();
  updateNodeStates();
}

function dependenciesMet(skill){
  if(!skill.requires || skill.requires.length===0) return true;
  return skill.requires.every(rid => state.unlocked[rid]);
}

function updateNodeStates(){
  Object.values(SKILLS).forEach(s=>{
    const el = document.getElementById('node-'+s.id);
    const unlocked = !!state.unlocked[s.id];
    if(unlocked){
      el.classList.remove('locked'); el.classList.add('unlocked');
    } else {
      el.classList.remove('unlocked'); el.classList.add('locked');
    }
    // lock if deps not met or insufficient points
    const canAfford = state.points >= s.cost;
    if(!unlocked && dependenciesMet(s) && canAfford){
      el.style.transform = 'scale(1.00)';
    } else {
      el.style.transform = 'scale(0.98)';
    }
  });
  document.getElementById('pointsRem').innerText = state.points;
}

/* ========================
   Skill toggling & effects
   ======================== */
function applyAllSkillEffects(){
  // reset settings to base
  state.settings = {
    playerSpeed: 3.0,
    canDoubleJump: false,
    canDash: false,
    canShoot: false,
    attackCooldown: 600,
    maxHp: 5,
    hp: state.settings.hp || 5,
    critChance: 0.02
  };
  // apply in unlocked order
  Object.keys(state.unlocked).forEach(id=>{
    if(state.unlocked[id]) {
      const skill = SKILLS[id];
      if(skill && typeof skill.applies === 'function'){
        skill.applies(state.settings);
      }
    }
  });
  // ensure hp not exceed max
  state.settings.hp = Math.min(state.settings.hp || state.settings.maxHp, state.settings.maxHp);
  document.getElementById('hpDisplay').innerText = state.settings.hp;
}

function unlockSkill(id){
  const skill = SKILLS[id];
  if(!skill) return;
  if(state.unlocked[id]) return;
  if(!dependenciesMet(skill)) { alert('Prerequisite not met.'); return; }
  if(state.points < skill.cost) { alert('Not enough points.'); return; }
  state.unlocked[id] = true;
  state.points -= skill.cost;
  applyAllSkillEffects();
  updateNodeStates();
  saveToStorage();
}

function lockSkill(id){
  // prevent locking a skill that other unlocked skills depend on
  const blocking = Object.values(SKILLS).some(s => (s.requires||[]).includes(id) && state.unlocked[s.id]);
  if(blocking){ alert('Cannot unlearn — other unlocked skills depend on this.'); return; }
  if(!state.unlocked[id]) return;
  const skill = SKILLS[id];
  state.unlocked[id] = false;
  state.points += skill.cost;
  applyAllSkillEffects();
  updateNodeStates();
  saveToStorage();
}

function toggleSkill(id){
  if(state.unlocked[id]) lockSkill(id); else unlockSkill(id);
}

/* ========================
   Save / Load
   ======================== */
function saveToStorage(){
  const payload = {points:state.points,unlocked:state.unlocked};
  localStorage.setItem(storageKey, JSON.stringify(payload));
}

function loadFromStorage(){
  const raw = localStorage.getItem(storageKey);
  if(!raw) return;
  try{
    const parsed = JSON.parse(raw);
    state.points = parsed.points ?? DEFAULT_POINTS;
    state.unlocked = parsed.unlocked ?? {};
    applyAllSkillEffects();
    updateNodeStates();
  }catch(e){}
}

/* ========================
   Reset
   ======================== */
document.getElementById('resetBtn').onclick = ()=>{
  if(!confirm('Reset all skill choices?')) return;
  state.points = DEFAULT_POINTS;
  state.unlocked = {};
  applyAllSkillEffects();
  updateNodeStates();
  saveToStorage();
};
document.getElementById('saveBtn').onclick = ()=>{
  saveToStorage();
  alert('Saved.');
};
document.getElementById('loadBtn').onclick = ()=>{
  loadFromStorage();
  alert('Loaded (if saved data existed).');
};

/* ========================
   Game: tiny 2D platformer-ish
   ======================== */
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let keys = {};
let score = 0;
let lastTime = 0;

// game objects
const world = {
  w: canvas.width,
  h: canvas.height,
  gravity: 0.9,
  platforms: []
};

const player = {
  x: 80, y: 340, vx:0, vy:0, w:28, h:36,
  grounded:false, jumpsLeft:1, dashTimer:0, dashCooldown:0, canDash:false,
  shootTimer:0, hp:5
};

const bullets = [];
const enemies = [];

/* init platforms & enemies */
function initWorld(){
  world.platforms = [
    {x:0,y:420,w:900,h:60},
    {x:180,y:320,w:140,h:14},
    {x:360,y:260,w:140,h:14},
    {x:560,y:200,w:120,h:14},
    {x:700,y:320,w:120,h:14},
  ];
  enemies.length = 0;
  enemies.push({x:480,y:360,w:28,h:28,vx:1.2,dir:1,hp:2});
  player.x=80; player.y=340; player.vx=0; player.vy=0;
  player.hp = state.settings.hp || state.settings.maxHp;
  document.getElementById('hpDisplay').innerText = player.hp;
}

function spawnEnemy(x,y){
  enemies.push({x,y,w:28,h:28,vx:1.2,dir:1,hp:2});
}

/* Input */
window.addEventListener('keydown', e => { keys[e.key.toLowerCase()] = true; });
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

document.getElementById('respawnBtn').onclick = ()=>{ initWorld(); score = 0; document.getElementById('score').innerText = score; };

/* Game Loop */
function gameLoop(ts){
  const dt = Math.min(32, ts - lastTime);
  lastTime = ts;
  update(dt);
  render();
  requestAnimationFrame(gameLoop);
}

function update(dt){
  // update player settings from skills
  player.speed = state.settings.playerSpeed || 3.0;
  player.canDoubleJump = state.settings.canDoubleJump;
  player.canDash = state.settings.canDash;
  player.canShoot = state.settings.canShoot;
  player.attackCooldown = state.settings.attackCooldown;
  player.critChance = state.settings.critChance;
  player.maxHp = state.settings.maxHp;

  // movement
  const left = keys['arrowleft'] || keys['a'];
  const right = keys['arrowright'] || keys['d'];
  const jump = keys['arrowup'] || keys[' '] || keys['w'];
  const dashKey = keys['shift'];
  const shootKey = keys['x'];

  // horizontal input
  if(left) player.vx = -player.speed;
  else if(right) player.vx = player.speed;
  else player.vx = 0;

  // jumping
  if(jumpPressed()) {
    if(player.grounded){
      player.vy = -13; player.grounded = false; player.jumpsLeft = player.canDoubleJump ? 1 : 0;
    } else if(player.jumpsLeft > 0){
      player.vy = -12; player.jumpsLeft -= 1;
    }
  }

  // dash
  if(player.canDash){
    if(dashKey && player.dashCooldown <= 0){
      const dir = right ? 1 : (left ? -1 : (player.vx >= 0 ? 1 : -1));
      player.vx = dir * (player.speed * 5);
      player.dashCooldown = 600; // ms
      player.dashTimer = 120;
    }
  }
  if(player.dashTimer > 0){ player.dashTimer -= dt; if(player.dashTimer <= 0) player.vx = 0; }
  if(player.dashCooldown > 0) player.dashCooldown -= dt;

  // gravity & integration
  player.vy += world.gravity * (dt/16);
  player.x += player.vx * (dt/16) * 6;
  player.y += player.vy * (dt/16) * 6;

  // collisions with platforms
  player.grounded = false;
  for(const p of world.platforms){
    if(rectIntersect(player.x, player.y, player.w, player.h, p.x, p.y, p.w, p.h)){
      // simple resolution - put player on top
      if(player.vy > 0 && (player.y + player.h) - p.y < 50){
        player.y = p.y - player.h - 0.01;
        player.vy = 0;
        player.grounded = true;
        player.jumpsLeft = player.canDoubleJump ? 1 : 0;
      } else {
        // horizontal pokeback
        if(player.x < p.x) player.x = p.x - player.w - 0.01;
        else player.x = p.x + p.w + 0.01;
        player.vx = 0;
      }
    }
  }
  // world bounds
  player.x = Math.max(0, Math.min(world.w - player.w, player.x));
  player.y = Math.min(world.h - player.h, player.y);
  if(player.y >= world.h - player.h - 1) { // fell below
    // respawn
    player.x = 80; player.y = 120; player.vx = 0; player.vy = 0;
    player.hp = Math.max(1, player.hp - 1);
    document.getElementById('hpDisplay').innerText = player.hp;
  }

  // shooting
  player.shootTimer -= dt;
  if(player.canShoot && shootKey && player.shootTimer <= 0){
    player.shootTimer = player.attackCooldown;
    const dir = (right ? 1 : (left ? -1 : 1));
    bullets.push({x:player.x + player.w/2 + dir*10, y:player.y + player.h/2, vx:dir*10, life:120, dmg:1});
  }

  // bullets update
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.x += b.vx;
    b.life -= dt;
    // check collisions with enemies
    for(let j=enemies.length-1;j>=0;j--){
      const e = enemies[j];
      if(rectIntersect(b.x,b.y,6,6,e.x,e.y,e.w,e.h)){
        // damage with crit chance
        const isCrit = Math.random() < player.critChance;
        const dmg = b.dmg * (isCrit ? 2 : 1);
        e.hp -= dmg;
        bullets.splice(i,1);
        if(e.hp <= 0){ enemies.splice(j,1); score += 10; document.getElementById('score').innerText = score; }
        break;
      }
    }
    if(b.life <= 0) bullets.splice(i,1);
  }

  // enemies AI
  enemies.forEach(e=>{
    e.x += e.vx * e.dir * (dt/16);
    // flip on bounds
    if(e.x < 50 || e.x > world.w-50) e.dir *= -1;
    // collide with player
    if(rectIntersect(e.x,e.y,e.w,e.h,player.x,player.y,player.w,player.h)){
      // damage cooldown?
      if(!e.lastHit || (performance.now()-e.lastHit)>600){
        e.lastHit = performance.now();
        player.hp -= 1;
        document.getElementById('hpDisplay').innerText = player.hp;
        if(player.hp <= 0) {
          // death -> respawn with penalty
          player.hp = Math.max(1, state.settings.maxHp);
          player.x = 80; player.y = 120;
          score = Math.max(0, score - 20);
          document.getElementById('score').innerText = score;
        }
      }
    }
  });

  // occasionally spawn new enemy
  if(Math.random() < 0.005) spawnEnemy(820,360);
}

function jumpPressed(){
  // simple edge detection
  if(jumpPressed.last) {
    if(keys['arrowup'] || keys[' '] || keys['w']) return false;
    jumpPressed.last = false; return false;
  }
  if(keys['arrowup'] || keys[' '] || keys['w']){
    jumpPressed.last = true; return true;
  }
  return false;
}

/* Rendering */
function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // background parallax
  ctx.fillStyle = '#061a29'; ctx.fillRect(0,0,canvas.width,canvas.height);

  // draw platforms
  for(const p of world.platforms){
    drawRoundedRect(ctx, p.x, p.y, p.w, p.h, 6, '#0e3a54', '#08324a');
  }

  // draw player
  ctx.save();
  ctx.translate(player.x, player.y);
  ctx.fillStyle = '#7ee5b5';
  roundRect(ctx, 0, 0, player.w, player.h, 6, true, false);
  // simple eyes
  ctx.fillStyle = '#071827'; ctx.fillRect(6,10,4,4); ctx.fillRect(player.w-10,10,4,4);
  ctx.restore();

  // bullets
  ctx.fillStyle = '#ffd39b';
  bullets.forEach(b => roundRect(ctx, b.x, b.y, 6, 6, 3, true, false));

  // enemies
  enemies.forEach(e=>{
    ctx.fillStyle = '#f87b7b';
    roundRect(ctx, e.x, e.y, e.w, e.h, 6, true, false);
  });
}

/* Utilities */
function rectIntersect(x1,y1,w1,h1,x2,y2,w2,h2){
  return !(x1+w1 < x2 || x1 > x2+w2 || y1+h1 < y2 || y1 > y2+h2);
}
function roundRect(ctx, x, y, w, h, r, fill=true, stroke=false){
  ctx.beginPath();
  ctx.moveTo(x+r, y);
  ctx.arcTo(x+w, y, x+w, y+h, r);
  ctx.arcTo(x+w, y+h, x, y+h, r);
  ctx.arcTo(x, y+h, x, y, r);
  ctx.arcTo(x, y, x+w, y, r);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}
function drawRoundedRect(ctx,x,y,w,h,r,fillGradientStart, fillGradientEnd){
  // gradient subtle
  const g = ctx.createLinearGradient(x,y,x,y+h);
  g.addColorStop(0, '#083444'); g.addColorStop(1,'#052732');
  ctx.fillStyle = g;
  roundRect(ctx,x,y,w,h,r,true,false);
}

/* ========================
   Init & run
   ======================== */
renderTree();
applyAllSkillEffects();
initWorld();
loadFromStorage();
requestAnimationFrame(gameLoop);

/* expose for debug */
window._STATE = state;
</script>
</body>
</html>
